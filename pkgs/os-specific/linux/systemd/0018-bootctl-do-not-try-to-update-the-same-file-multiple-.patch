From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Yu Watanabe <watanabe.yu+github@gmail.com>
Date: Wed, 19 Jun 2024 15:55:59 +0900
Subject: [PATCH] bootctl: do not try to update the same file multiple times

Otherwise, copy_file_with_version_check() -> version_check() will fail
and warn about that the same version is already installed.

Fixes a regression caused by 929f41c6528fb630753d4e2f588a8eb6c2f6a609.
Fixes #33392.

bootctl: add missing error messages in version_check()

bootctl: check file type before update

This also adds missing assertions.

Follow-up for 929f41c6528fb630753d4e2f588a8eb6c2f6a609.
---
 src/bootctl/bootctl-install.c | 22 ++++++++++++++++++----
 1 file changed, 18 insertions(+), 4 deletions(-)

diff --git a/src/bootctl/bootctl-install.c b/src/bootctl/bootctl-install.c
index e15c2c6bed..7828ce1f08 100644
--- a/src/bootctl/bootctl-install.c
+++ b/src/bootctl/bootctl-install.c
@@ -195,14 +195,14 @@ static int version_check(int fd_from, const char *from, int fd_to, const char *t
         if (r == -ESRCH)
                 return log_notice_errno(r, "Source file \"%s\" does not carry version information!", from);
         if (r < 0)
-                return r;
+                return log_error_errno(r, "Failed to get version information of source file \"%s\": %m", from);
 
         r = get_file_version(fd_to, &b);
         if (r == -ESRCH)
                 return log_notice_errno(r, "Skipping \"%s\", it's owned by another boot loader (no version info found).",
                                         to);
         if (r < 0)
-                return r;
+                return log_error_errno(r, "Failed to get version information of \"%s\": %m", to);
         if (compare_product(a, b) != 0)
                 return log_notice_errno(SYNTHETIC_ERRNO(ESRCH),
                                         "Skipping \"%s\", it's owned by another boot loader.", to);
@@ -324,11 +324,15 @@ static int create_subdirs(const char *root, const char * const *subdirs) {
         return 0;
 }
 
-static int update_efi_boot_binaries(const char *esp_path, const char *source_path) {
+static int update_efi_boot_binaries(const char *esp_path, const char *source_path, const char *exclude_path) {
         _cleanup_closedir_ DIR *d = NULL;
         _cleanup_free_ char *p = NULL;
         int r, ret = 0;
 
+        assert(esp_path);
+        assert(source_path);
+        assert(exclude_path);
+
         r = chase_and_opendir("/EFI/BOOT", esp_path, CHASE_PREFIX_ROOT|CHASE_PROHIBIT_SYMLINKS, &p, &d);
         if (r == -ENOENT)
                 return 0;
@@ -339,9 +343,19 @@ static int update_efi_boot_binaries(const char *esp_path, const char *source_pat
                 _cleanup_close_ int fd = -EBADF;
                 _cleanup_free_ char *v = NULL;
 
+                if (!IN_SET(de->d_type, DT_REG, DT_UNKNOWN))
+                        continue;
+
                 if (!endswith_no_case(de->d_name, ".efi"))
                         continue;
 
+                /* Skip the file that is already updated. We cannot check if the paths are equal because the
+                 * file system is likely case insensitve. It's easiest to just check if the inodes are the
+                 * same.
+                 */
+                if (inode_same_at(dirfd(d), de->d_name, 0, exclude_path, 0))
+                        continue;
+
                 fd = xopenat_full(dirfd(d), de->d_name, O_RDONLY|O_CLOEXEC|O_NONBLOCK|O_NOCTTY|O_NOFOLLOW, /* xopen_flags= */ 0, /* mode= */ 0);
                 if (fd < 0)
                         return log_error_errno(fd, "Failed to open \"%s/%s\" for reading: %m", p, de->d_name);
@@ -429,7 +443,7 @@ static int copy_one_file(const char *esp_path, const char *name, bool force) {
                 /* If we were installed under any other name in /EFI/BOOT, make sure we update those binaries
                  * as well. */
                 if (!force)
-                        RET_GATHER(ret, update_efi_boot_binaries(esp_path, source_path));
+                        RET_GATHER(ret, update_efi_boot_binaries(esp_path, source_path, default_dest_path));
         }
 
         return ret;
